#N canvas 566 127 625 661 10;
#X declare -lib Gem -lib pdp -lib gridflow -lib mpc;
#X obj 28 65 tgl 20 0 empty buffer.fill empty 17 7 0 10 -204786 -258113
-1 0 1;
#X msg 133 300 put_at \$1 0 0 0;
#X obj 28 276 #cast b;
#N canvas 22 496 278 238 check_movie_dim 0;
#X obj 26 37 #t;
#X obj 41 60 #dim;
#X obj 41 82 #change;
#X obj 26 12 inlet;
#X obj 26 198 outlet;
#X obj 41 104 #to_list;
#X obj 41 126 list split 2;
#X obj 41 174 s height_width;
#X msg 173 167 size h\$1 w\$2;
#X obj 173 191 outlet;
#X connect 0 0 4 0;
#X connect 0 1 1 0;
#X connect 1 0 2 0;
#X connect 2 0 5 0;
#X connect 3 0 0 0;
#X connect 5 0 6 0;
#X connect 6 0 7 0;
#X connect 6 0 8 0;
#X connect 8 0 9 0;
#X restore 28 182 pd check_movie_dim;
#X obj 133 205 display;
#N canvas 230 363 320 371 adjust_buffer_size 0;
#X msg 39 271 1 b #;
#X obj 12 292 # + 0;
#X obj 39 251 loadbang;
#X obj 12 203 t a b;
#X obj 12 327 outlet;
#X obj 12 8 r height_width;
#X msg 112 254 reassign;
#X msg 12 231 \$2 \$1 \$2 3 b #;
#X msg 27 173 1 1;
#X text 56 167 <- in order to avoid memory usage peaks;
#X obj 12 50 #t;
#X obj 27 150 b;
#X text 74 180 we load first a very small grid \, then;
#X text 73 194 the 'real' one.;
#X obj 12 72 b;
#X obj 12 131 list append;
#X obj 12 29 t b a;
#X obj 12 98 delay 0;
#X connect 0 0 1 1;
#X connect 1 0 4 0;
#X connect 2 0 0 0;
#X connect 3 0 7 0;
#X connect 3 1 6 0;
#X connect 5 0 16 0;
#X connect 6 0 4 0;
#X connect 7 0 1 0;
#X connect 8 0 3 0;
#X connect 10 0 14 0;
#X connect 10 1 11 0;
#X connect 11 0 8 0;
#X connect 14 0 17 0;
#X connect 15 0 3 0;
#X connect 16 0 10 0;
#X connect 16 1 15 1;
#X connect 17 0 15 0;
#X restore 181 373 pd adjust_buffer_size;
#X obj 28 402 #store (640 480 640 3 b #);
#N canvas 39 123 269 344 read_cursor 0;
#X obj 25 280 #join 2;
#X obj 25 59 #t;
#X obj 25 190 #reverse -1;
#X obj 58 136 #for (0 0) (480 640) (1 1);
#X obj 25 168 #store;
#X obj 25 145 b;
#X obj 158 226 # + 0;
#X obj 25 33 inlet;
#X obj 25 306 outlet;
#X obj 115 26 r height_width;
#X obj 115 52 t b a a;
#X obj 158 177 list append;
#X msg 158 203 \$2 \$3 1 # \$1;
#X connect 0 0 8 0;
#X connect 1 0 5 0;
#X connect 1 1 11 0;
#X connect 2 0 0 0;
#X connect 3 0 4 1;
#X connect 4 0 2 0;
#X connect 5 0 4 0;
#X connect 6 0 0 1;
#X connect 7 0 1 0;
#X connect 9 0 10 0;
#X connect 10 0 3 0;
#X connect 10 1 3 1;
#X connect 10 2 11 1;
#X connect 11 0 12 0;
#X connect 12 0 6 0;
#X restore 359 267 pd read_cursor;
#N canvas 11 453 265 259 fill_cursor_pos 0;
#X obj 61 97 f;
#X obj 93 98 + 1;
#X msg 148 115 0;
#X obj 61 121 sel 640;
#X obj 34 73 t a b;
#X obj 34 34 inlet;
#X obj 34 206 outlet;
#X obj 100 204 outlet;
#X obj 147 26 r height_width;
#X obj 147 48 t a b;
#X obj 148 154 s buffer.fill;
#X msg 147 72 \$2;
#X connect 0 0 1 0;
#X connect 0 0 3 0;
#X connect 1 0 0 1;
#X connect 2 0 0 1;
#X connect 2 0 10 0;
#X connect 3 0 2 0;
#X connect 3 1 7 0;
#X connect 4 0 6 0;
#X connect 4 1 0 0;
#X connect 5 0 4 0;
#X connect 8 0 9 0;
#X connect 9 0 11 0;
#X connect 9 1 2 0;
#X connect 11 0 3 1;
#X restore 28 230 pd fill_cursor_pos;
#X obj 359 298 s read_cursor;
#X obj 28 372 r read_cursor;
#N canvas 275 459 288 211 read_cursor_pos 0;
#X obj 29 59 f;
#X obj 74 61 + 1;
#X obj 108 39 r height_width;
#X msg 108 63 \$2;
#X obj 74 84 sel;
#X msg 74 106 0;
#X obj 29 26 inlet;
#X obj 29 156 outlet;
#X obj 74 127 s read.onoff;
#X connect 0 0 1 0;
#X connect 0 0 7 0;
#X connect 1 0 4 0;
#X connect 2 0 3 0;
#X connect 3 0 4 1;
#X connect 4 0 5 0;
#X connect 4 1 0 1;
#X connect 5 0 8 0;
#X connect 5 0 0 1;
#X connect 6 0 0 0;
#X restore 359 208 pd read_cursor_pos;
#N canvas 481 273 450 300 progressbar 0;
#X obj 100 256 s \$0.progressbar;
#X obj 100 92 inlet;
#X obj 247 46 r height_width;
#X obj 247 91 - 1;
#X msg 247 69 \$2;
#X obj 100 120 /;
#X obj 100 142 t a a;
#X obj 100 197 int;
#X obj 100 175 * 138;
#X obj 206 198 int;
#X obj 206 176 * 100;
#X msg 206 231 label \$1%;
#X msg 100 233 vis_size \$1 14;
#X obj 23 21 cnv 5 5 14 empty empty empty 20 12 0 14 -262144 -66577
0;
#X obj 21 21 cnv 1 1 14 empty \$0.progressbar 0% 65 8 0 12 -233017
-66577 0;
#X obj 169 140 outlet;
#X msg 159 62 0;
#X connect 1 0 5 0;
#X connect 1 0 15 0;
#X connect 2 0 4 0;
#X connect 3 0 5 1;
#X connect 4 0 3 0;
#X connect 5 0 6 0;
#X connect 6 0 8 0;
#X connect 6 1 10 0;
#X connect 7 0 12 0;
#X connect 8 0 7 0;
#X connect 9 0 11 0;
#X connect 10 0 9 0;
#X connect 11 0 0 0;
#X connect 12 0 0 0;
#X connect 16 0 5 0;
#X coords 0 -1 1 1 140 16 2 20 20;
#X restore 140 257 pd progressbar;
#X text 33 44 1;
#X text 180 114 0;
#X text 364 104 2;
#X text 384 127 <- play the buffer tx-transformed;
#X floatatom 140 279 5 0 0 0 - - -;
#X floatatom 368 232 5 0 0 0 - - -;
#X text 5 29 Copyright 2010 Roman Haefeli;
#N canvas 187 241 449 363 ABOUT 0;
#X text 15 13 TX-TRANSFORM;
#X text 16 22 ------------;
#X text 16 39 Think of a movie as a big cuboid of pixels. The horizontal
axis represents the frame width \, the vertical axis the frame height
\, and the Z-axis the frame numbers. Recording a movie could be seen
as writing one frame behind the next along the Z-axis into that cuboid.
Similarly \, playing a movie could be seen as a plane (the projection
we see) travelling along the Z-axis \, hitting one frame after another.
;
#X text 17 151 In this patch \, the projection plane does not travel
from the front to the rear \, but from left to right. In the first
frame \, the left-most pixel columns from all stored frames are stitched
together \, in the second frame all second-from-left columns \, etc.
'left' is swapped with 'early' \, 'right' with 'late'. Thus \, the
name T(ime)-X(left-right)-transformation.;
#X text 16 261 http://www.tx-transform.com/;
#X text 16 289 NOTE:;
#X text 16 305 Martin Reinhart \, the 'inventor' of tx-transform \,
claims to hold a patent on the described method.;
#X restore 359 71 pd ABOUT;
#X obj 0 0 doc_demo;
#X text 182 132 <- select source;
#X obj 28 474 fps;
#X msg 28 495 \$1 fps;
#X obj 28 518 display;
#X obj 359 125 tgl 20 0 empty buffer.fill empty 17 7 0 10 -204786 -258113
-1 0 1;
#X obj 359 165 metro 33;
#X text 329 429 NOTE:;
#X text 329 446 This patch might eat all your memory!!;
#X obj 359 340 import Gem pdp gridflow mpc;
#X obj 28 135 mpc.gf.source;
#X obj 28 98 mpc.gf.setfps 30;
#X obj 195 504 bng 15 250 50 0 empty empty empty 0 -6 0 8 -24198 -1
-1;
#X obj 225 553 bng 15 250 50 0 empty empty empty 0 -6 0 8 -24198 -1
-1;
#X obj 210 528 bng 15 250 50 0 empty empty empty 0 -6 0 8 -24198 -1
-1;
#X obj 181 583 #record;
#X text 215 502 <-- 1 select filename;
#X text 230 527 <-- 2 start recording;
#X text 245 553 <-- 3 stop recording;
#X text 244 582 <-- open for more options;
#X text 53 67 <- fill the buffer (click twice);
#X text 200 147 SD 16+ Sec Clips;
#X msg 38 316 open window \, title original;
#X obj 28 340 #out window \, title original;
#X text 329 459 Try movies with small dimensions first (320x240px \,
for instance).;
#X obj 28 451 #out window \, title tx-transform \, move 300 0;
#X msg 44 427 open window \, title tx-transform \, move 300 0;
#X text 428 524 Maybe OSX has much lower limits of memory size for
shmget()? Need increse?;
#X connect 0 0 32 0;
#X connect 1 0 6 1;
#X connect 2 0 6 1;
#X connect 2 0 44 0;
#X connect 3 0 8 0;
#X connect 3 1 4 0;
#X connect 5 0 6 1;
#X connect 6 0 36 0;
#X connect 6 0 46 0;
#X connect 7 0 9 0;
#X connect 8 0 2 0;
#X connect 8 1 1 0;
#X connect 8 1 12 0;
#X connect 10 0 6 0;
#X connect 11 0 7 0;
#X connect 11 0 18 0;
#X connect 12 0 17 0;
#X connect 23 0 24 0;
#X connect 24 0 25 0;
#X connect 26 0 27 0;
#X connect 27 0 11 0;
#X connect 31 0 3 0;
#X connect 32 0 31 0;
#X connect 33 0 36 1;
#X connect 34 0 36 3;
#X connect 35 0 36 2;
#X connect 43 0 44 0;
#X connect 46 0 23 0;
#X connect 47 0 46 0;
